/*
	https://developer.roku.com/docs/developer-program/debugging/external-control-api.md
*/


//******************
// Compiler Directives / Libraries
//******************

#default_volatile
#enable_trace
#print_to_trace

#define_constant debug 0
#define_constant maxRokuDevices 5
#define_constant maxUDPLines 20

                 

//******************
// Input / Outputs 
//******************          

DIGITAL_INPUT keepUDPEnabled, pollDevices;
STRING_INPUT rokuPrimarySerial[150];

STRING_OUTPUT rokuPrimaryIp;



//******************
// Sockets
//******************   

UDP_SOCKET MyUDP[1024];         



//******************
// Structures
//******************


STRUCTURE strucRokuDevice
{
	STRING ipAddress[75];			// 192.168.1.123
	STRING serialNumber[75]; 		// YJ002J706204
	STRING location[75];			// http://192.168.1.123:8060/
	STRING lastSeen[25];			// YYYY/MM/DD HH:MM:SS
};

                                        



//******************
// Globals
//******************

STRING gsi_UDP_IPAddress[50];

NONVOLATILE STRING gsi_rokuPrimaryIp[75];

INTEGER gai_UDP_PortNumber;

strucRokuDevice g_RokuDevices[maxRokuDevices];

                    


                           
       
//******************
// Functions
//******************


STRING_FUNCTION timestamp()
{
	STRING datetime[30];
	datetime = date(3) + " " + time();
	return(datetime);
}
              


INTEGER_FUNCTION findEmpty() 
{
	INTEGER i, emptyFound;
	i = 0;
	emptyFound = 0;
	while(i < maxRokuDevices && !emptyFound) {
		if(g_RokuDevices[i].serialNumber = "") emptyFound = 1;
		else i = i + 1;
	}
	return(i);
}





FUNCTION updateDeviceList()
{
	INTEGER i;

	for	(i = 0 to maxRokuDevices)
	{
		if(debug) print ("%d   |%s| |%s| |%s|  |%s|\n", i, g_RokuDevices[i].serialNumber, g_RokuDevices[i].location, g_RokuDevices[i].ipAddress, g_RokuDevices[i].lastSeen);                
		if (g_RokuDevices[i].serialNumber = lower(rokuPrimarySerial))
		{
			gsi_rokuPrimaryIp = g_RokuDevices[i].ipAddress;
			rokuPrimaryIp = gsi_rokuPrimaryIp;
		}
 	}
}




FUNCTION parseUDP(STRING rx, STRING ip)
{
	INTEGER i, iLoc1, iLoc2, existing, existingEntryNum;
	STRING line[150];
	STRING lines[maxUDPLines][150];
	strucRokuDevice thisRoku;

	thisRoku.lastSeen = timestamp();
	thisRoku.ipAddress = ip;

	i = 0;
	iLoc1 = find("\n", rx);
	line = mid(rx, 1, iLoc1);
   	lines[i] = line;

	do 
	{
		i = i + 1;
		iLoc1 = find("\n", rx, iLoc1+1);
		iLoc2 = find("\n", rx, iLoc1+1);
		line = mid(rx, iLoc1, iLoc2-iLoc1);
		lines[i] = line;
	} until (!iLoc1);
	    
	for	(i = 0 to maxUDPLines)
	{
	
		if(find("usn: uuid:roku:ecp", lines[i]))
		{
			thisRoku.serialNumber = right(lines[i], len(lines[i])-21 );
		} 
		else if(find("location: http", lines[i]))
		{
			thisRoku.location = right(lines[i], len(lines[i])-12 );
		} 
   	}
      
    
	if(debug) print("serial: \'%s\'\n", thisRoku.serialNumber);
	if(debug) print("location: \'%s\'\n", thisRoku.location);
	if(debug) print("ip: \'%s\'\n", thisRoku.ipAddress);
	if(debug) print("lastSeen: \'%s\'\n", thisRoku.lastSeen);

	// check if existing, if so update, otherwise add.         
	existing = 0;
	for	(i = 0 to maxRokuDevices)
	{	
		if (g_RokuDevices[i].serialNumber = thisRoku.serialNumber) {existing = 1; existingEntryNum = i;}
	}
   
	if(existing) 
	{
		i = existingEntryNum;
	} 
	else
	{
		i = findEmpty();
	}

	g_RokuDevices[i].serialNumber = thisRoku.serialNumber;
	g_RokuDevices[i].location = thisRoku.location;
	g_RokuDevices[i].ipAddress = thisRoku.ipAddress;
	g_RokuDevices[i].lastSeen = thisRoku.lastSeen;

	updateDeviceList(); 
}

               





FUNCTION listenUDPSocket(integer enable)
{
    SIGNED_INTEGER status;
    signed_integer iStatus;
	string siUDP_Tx[1000];    

	if (enable) 
	{
		if(debug) print("Enable UDP Socket");
	    status = SocketUDP_Enable(MyUDP, gsi_UDP_IPAddress, gai_UDP_PortNumber);
	}
	else
	{
		if(debug) print("Disable UDP Socket");
		status = SocketUDP_Disable (MyUDP);
	}

    if (status < 0)
        if(debug) print("Error listening to %s on port  %d", gsi_UDP_IPAddress, gai_UDP_PortNumber);           
}

        

FUNCTION pollRokuDevices()
{
    SIGNED_INTEGER status;
    signed_integer iStatus;
	string siUDP_Tx[1000];

	if (!keepUDPEnabled) 
	{
		listenUDPSocket(1);
		delay(100);
	}

	// Send SSDP Query 
	if(debug) print("Send M-SEARCH on UDP Socket");
    siUDP_Tx = "M-SEARCH * HTTP/1.1\nHost: " + gsi_UDP_IPAddress + ":" + itoa(gai_UDP_PortNumber) + "\nMan: \"ssdp:discover\"\nST: roku:ecp\n";
    iStatus = SocketSend(MyUDP, siUDP_Tx );
    if (iStatus < 0)
        if(debug) print("Error Sending to MyUDP: %d\n", iStatus);
      
	if (!keepUDPEnabled) 
	{
		delay(1000); // keep udp open for 10 seconds
		listenUDPSocket(0);
	}              
}





//******************
// Event Handlers 
//******************


SOCKETRECEIVE MyUDP
{
	STRING SenderIPAddress[50];
	STRING rx[500];

	SocketGetSenderIPAddress(MyUDP, SenderIPAddress);
  	if(debug) print("  ***  Multicast data received from %s\n", SenderIPAddress);      
 
	rx = lower(MyUDP.SocketRxBuf);
	if (find("usn: uuid:roku:", rx))
	{
		parseUDP(rx, SenderIPAddress);
	}	
    ClearBuffer(MyUDP.SocketRxBuf);

}

             

PUSH keepUDPEnabled
{
     listenUDPSocket(1);
}


RELEASE keepUDPEnabled
{
     listenUDPSocket(0);
}


PUSH pollDevices
{
	pollRokuDevices();
}
        

CHANGE rokuPrimarySerial
{  
	pollRokuDevices(); // remove this if startup is impacted
	updateDeviceList();
}





//*******************
// Main (Startup Code)
//*******************

Function Main()
{
    waitforinitializationcomplete();

	gsi_UDP_IPAddress = "239.255.255.250";
	gai_UDP_PortNumber = 1900;

	rokuPrimaryIp = gsi_rokuPrimaryIp;
}
